---
title: 'Aufgabenblatt 02: Generalisierte lineare Modelle'
author: "Anatol"
date: "3/22/2022"
output: 
  html_document:
    code_folding: hide
    df_print: kable
    fig_caption: yes
    fig_height: 5
    fig_width: 5
    theme: united
    self_contained: yes
    toc: yes
    toc_float: yes
    toc_level: 3
---

```{r, include = FALSE}
library(dplyr)
library(magrittr)
library(flair)
library(pipeR)
library(knitr)
library(rmarkdown)
library(shiny)
library(shinyWidgets)
library(arm)
library(rAmCharts)
library(xfun)
library(car)
library(effects)
library(lmtest)
library(MASS)
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
      x)
  } else x
}

xfun::pkg_load2(c("htmltools", "mime"))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
.description {
  color: gray;
  font-style: italics;
```

# Aufgabe 1: Logit Modelle
```{r}
insur <- read.csv("insurance.csv")
head(insur)
str(insur)
summary(insur)
```
```{r}
any(is.na(insur))
```

```{r}
hist(insur$hhincome, breaks = 100, prob = TRUE)
```

## 1a)
*Aufgrund der Rechtsschiefe des Einkommens entscheiden Sie sich fur eine Logarithmierung. Addieren Sie zur Vermeidung von NAs dabei zur Ursprungsvariable zunachst die Konstante 0,001. Dummyvariablen sollten Sie zunachst zu Faktoren umwandeln.*

```{r}
summary(insur$hhincome)
insur$loghhincome <- insur$hhincome + 0.001
summary(insur$loghhincome)
insur$loghhincome <- log(insur$loghhincome)
summary(insur$loghhincome)
```


```{r}
hist(insur$loghhincome, breaks = 100, prob = TRUE)
```
```{r}
insur$ins <- as.factor(insur$ins)
insur$married <- as.factor(insur$married)
insur$retire <- as.factor(insur$retire)
insur$hstatusg <- as.factor(insur$hstatusg)
insur$hisp <- as.factor(insur$hisp)
str(insur)
```
## 1b)
*Passen Sie zunachst einmal das volle Modell an und nutzen Sie dabei den Logit-Link.*
```{r}
logRegFull <- glm(ins ~ married + retire + hstatusg + hhincome + 
                   age + hisp + educyear, family = binomial(link = "logit"), data = insur)
summary(logRegFull)
```
## 1c)
*Zur Diagnostik schauen Sie sich den binned residual plot an. Dazu verwenden Sie die Funktion binnedplot aus dem arm-Paket und plotten die geﬁtteten Werte auf die Abszisse und die Residuen auf die Ordinate. Wie
interpretieren Sie die Graﬁk? Die Funktion binned.resids mit den bereits zum Plotten genutzten Argumenten
konnte Ihnen hier helfen.*

```{r}
binnedplot(logRegFull$fitted.values, logRegFull$residuals)
binned.resids(logRegFull$fitted.values, logRegFull$residuals)
```

Die Residuen scheinen im Mittelwert Null zu sein und konstante Varianz (Homoskedastizitat) zu haben.

## 1d)
*Interpretieren Sie zunachst ganz allgemein die Regressionskoffizienten Ihres Modells. Wie verandert sich c.p. durch eine Heirat die Chance, krankenversichert zu sein? Wie verandert sich c.p. die Chance, wenn eine Person ein weiteres Ausbildungsjahr absolviert hat?*

Die Chance, krankversichert zu sein, erhoht sich durch eine Heirat und die Absolvierung eines weiteren Ausbildungsjahres.

## 1e)
*Berechnen Sie den durchschnittlichen marginalen Effekt einer Veranderung der Variable retire.*

```{r}
eff_retire <- fitted(logRegFull)*(1 - fitted(logRegFull))*coef(logRegFull)["retire1"]
ame_retire <- mean(eff_retire)
ame_retire

```
Der durchschnittliche marginale Effekt einer Veranderung der Variable retire ist 0.0427516: im Mittel uber alle Personen haben wir einen positiven Effekt von Renter-Status einer Person von 0.0427616 der Wahrscheinlichkeit, dass die Person krankversichert ist.

## 1f)
*Passen Sie ein Modell ohne die Variablen married, retire und hisp an. Berechnen Sie sodann anhand dieses Modells den marginalen Effekt im Mittelwert bezuglich der Variable educyear.*

```{r}
logRegRest <- glm(ins ~ hstatusg + hhincome + 
                   age + educyear, family = binomial(link = "logit"), data = insur)
summary(logRegRest)

X <- model.matrix(logRegRest)
X_bar <- colMeans(X)
eta_bar <- X_bar %*% coef(logRegRest)
mem_educyear <- binomial()$linkinv(eta_bar) * (1 - binomial()$linkinv(eta_bar)) * coef(logRegRest)["educyear"]
mem_educyear
```

Der marginale Effekt im Mittelwert bezuglich der Variable educyear betragt 0.03. Positiver Effekt  eines weiteren Bildungsjahres auf die Wahrscheinlichkeit, krankversichert zu sein. Jedes weitere Bildungsjahr erhoht die Wahrscheinlichkit um 0.03.

## 1g)
*Schauen Sie sich die Effektplots fur die Variable educyear im Modell aus Teilaufgabe b) an. Hinweis: Nutzen Sie die Funktion allEffects aus dem effects-Paket.*

```{r}
plot(allEffects(logRegFull)[7])

```

## 1h)
*Wie hoch ist der Anteil korrekt vorhergesagter Werte im Modell aus Teilaufgabe b)? Als Schwellenwert setzen
Sie 0,5 an.*

```{r}
marg_table_insr <- prop.table(table(Obs = insur$ins, Pred = round(fitted(logRegFull))))
marg_table_insr
marg_table_insr[1, 1] + marg_table_insr[2, 2]


```

Beim Schwellenwert von 0.5 ist der Anteil der korrekt vorhergesagten Werte betragt 62.45%.

## 1i)
*Berechnen Sie fur das Modell aus Teilaufgabe b) das Pseudo-R2.*

```{r}
logRegNull <- glm(ins ~ 1, family = binomial(link = "logit"), data = insur)

PseudoR2 <- 1 - logLik(logRegFull)/logLik(logRegNull)
PseudoR2

```

Das Pseudo-R2 fur das Modell aus Teilaufgabe b) betragt 0.0677

## 1j)
*Fuhren Sie fur das Modell aus Teilaufgabe b) einen Test auf Fehlspeziﬁkation durch. Hinweis: Nutzen Sie die Funktion lrtest aus dem lmtest-Paket.
*

```{r}
lrtest(logRegFull, . ~ . + I(predict(logRegFull, type = "link")^2))
```
Da das erweiterte Modell mit $\widehat{η^2_i}$ eine signifikanz kleinere Signifikanz als das Modell ohne $\widehat{η^2_i}$, ist das Modell inkorrekt spezifiziert. Wie konnen davon ausgehen, dass quadrierter linearer Pradiktor einen signifikanten Erklarungsgehalt hatte.


## 1k)
*Fuhren Sie eine Variablenselektion mit der schrittweisen Selektion durch. Gehen Sie vom Modell aus Teilaufgabe b) aus und geben Sie dieses Modell mit samtlichen Interaktionstermen zweiter Ordnung als Maximalmodellan (uber Nutzung von ^2 in Formel). Nutzen Sie dabei das Paket MASS.*
```{r}
logRegMax <- glm(ins ~ married + retire + hstatusg + hhincome + 
                   age + hisp + educyear + married^2 + retire^2 + hstatusg^2 + hhincome^2 + 
                   age^2 + hisp^2 + educyear^2, family = binomial(link = "logit"), data = insur)
stepAIC(logRegMax, direction = "backward")
```
Schrittweise Selektion (AIC): das Maximalmodell als Ausgangsmodell: $ins = β_0 + β_1*married + β_2*retire + β_3*hstatusg + β_4*hhincome + β_5*hisp + β_6*educyear$. 